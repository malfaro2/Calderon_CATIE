---
title: "spatial model for redundancy 2"
author: "Erick Calder√≥n-Morales"
date: "April 9, 2019"
output:   
    html_document:
    code_folding: hide
    fig_height: 8
    fig_width: 10
    keep_md: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
---

```{r message=FALSE, warning=FALSE}
#Paquetes
library(kableExtra)
library(lattice)
library(tidyverse)
library(PerformanceAnalytics)
library(janitor)
source("C:/tesis_catie/Calderon_CATIE/scripts/functions/HighstatLibV10.R")
library(ggbiplot)
library(sp)
library(raster)
library(dismo)
library(splancs)
library(INLA)
library(reshape)
library(gstat)
library(ggmap)
```

```{r}
#Load data
dredun_eff <- read.csv("C:/tesis_catie/Calderon_CATIE/data/resultados_csv/data_indices_eff_redundancy.csv", header=T)
dredun_eff <- clean_names(dredun_eff) %>% 
  dplyr::select(-c(d))

dparcelas <- read.csv("C:/tesis_catie/Calderon_CATIE/data/clean/data_posicion_parcelas.csv", header = T)
dparcelas <- clean_names(dparcelas)

denvi_est <- read.csv("C:/tesis_catie/Calderon_CATIE/data/clean/data_enviroment_worldclim_clean.csv", header = T, row.names = 1)
denvi_est <- denvi_est %>%
  clean_names() %>% 
    dplyr::select(-c(crtm_90_x,crtm_90_y,forest_type, slope_per,slope_deg))

#Standarize data
denvi_est <-  scale(denvi_est,center = F, scale = T )

#scale(denvi_est,center = F, scale = T )
denvi_est <- rownames_to_column(as.data.frame(denvi_est),var= "plot") %>% 
  dplyr::select(-tempsd )
```

#Join Data sets

```{r}
dfull  <- left_join(dredun_eff, dparcelas,by=c("plot") ) %>% 
  left_join(.,denvi_est, by=c("plot") )

#Ordenar columnas
dfull_est <- dfull %>% dplyr::select(plot, forest_type,longitude,latitude,crtm_90_x,crtm_90_y,n,redundancy,u , q, everything()) 
glimpse(dfull_est)
```

```{r}

#Data sets que se van a utilizar
dredundancy_eff <- dfull_est %>%
  dplyr::select(-u,-q)
  
duniqueness_eff <- dfull_est %>%
  dplyr::select(-redundancy,-q)

drao_eff <- dfull_est %>%
  dplyr::select(-u,-redundancy )
```

#Modelo lineal con componente espacial: redundancy 

```{r, fig.height=10, fig.width=10}
ncol(denvi_est)
pca_envi <- prcomp(denvi_est[,2:17], scale. = TRUE)
pca_envi$rotation
summary(pca_envi)

ggbiplot(pca_envi, obs.scale = 3, var.scale = 3,
  groups = dfull_est$forest_type, ellipse = TRUE) +
  scale_color_discrete(name = '') +
  theme(legend.direction = 'horizontal', legend.position = 'top')+
  theme_grey()
```


##Outliers
```{r, fig.width=12, fig.height=12}

MyVar <- c("longitude", "latitude", "sand","clay","limo",
           "p_h","acidity","ca","mg","k","p","organic_matter",
           "elev","prec","precdriest","preccv","temp","tempmin")

Mydotplot(dredundancy_eff[,MyVar])

dredundancy_eff[dredundancy_eff$preccv>50,]
dredundancy_eff[dredundancy_eff$p>10,]


```


##Collinearity

```{r}
corvif(dredundancy_eff[,MyVar])
```




##Relationships
```{r, fig.width=12, fig.height=12}

MyMultipanel.ggp2(Z = dredundancy_eff, 
                  varx = MyVar, 
                  vary = "redundancy", 
                  ylab = "Response variable: Redundancia",
                              addSmoother = TRUE,
                              addRegressionLine = FALSE,
                              addHorizontalLine = FALSE)


```


##Modelo inicial 


```{r}

pca_regresssion <- inla(redundancy ~
                          
                          pca_envi$x[,1] +
                          pca_envi$x[,2] +
                          pca_envi$x[,3],
                          
                        family = "gaussian",
          
          control.compute = list(
                               dic = TRUE,
                               waic = TRUE),
          control.predictor = list(compute = TRUE),
          data = dredundancy_eff 
          )
                          
                         
pca_regresssion$waic$waic

```



##Mesh

```{r}

Xkm <- dredundancy_eff$crtm_90_x / 1000
Ykm <- dredundancy_eff$crtm_90_y / 1000

Loc <- cbind(Xkm, Ykm)

```





```{r}
D <- dist(Loc)
par(mfrow = c(1,2), mar = c(5,5,2,2), cex.lab = 1.5)
hist(D, 
     freq = TRUE,
     main = "", 
     xlab = "Distance between sites (km)",
     ylab = "Frequency");text(2, 35000, "A", cex = 1.5)

plot(x = sort(D), 
     y = (1:length(D))/length(D), 
     type = "l",
     xlab = "Distance between sites (km)",
     ylab = "Cumulative proportion")
text(2, 1, "B", cex = 1.5)
```



```{r}
# We need a grid on top of our sampling points
ConvHull <- inla.nonconvex.hull(Loc)
mesh1 <- inla.mesh.2d(boundary = ConvHull, 
                      max.edge = c(200))

mesh1$n
```












