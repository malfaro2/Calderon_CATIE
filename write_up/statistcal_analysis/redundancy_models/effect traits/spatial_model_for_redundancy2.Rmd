---
title: "spatial model for redundancy 2"
author: "Erick Calder√≥n-Morales"
date: "April 9, 2019"
output: 
  html_document:
     code_folding: hide
     fig_height: 8
     fig_width: 10
     keep_md: yes
     toc: yes
     toc_depth: 2
     toc_float: yes
---

```{r message=FALSE, warning=FALSE}
#Paquetes
library(kableExtra)
library(lattice)
library(tidyverse)
library(PerformanceAnalytics)
library(janitor)
library(ggbiplot)
library(sp)
library(raster)
library(dismo)
library(splancs)
library(INLA)
library(reshape)
library(gstat)
library(ggmap)
source("C:/tesis_catie/Calderon_CATIE/scripts/functions/HighstatLibV10.R")
```

```{r warning=FALSE}
#Load data
dredun_eff <- read.csv("C:/tesis_catie/Calderon_CATIE/data/resultados_csv/data_indices_eff_redundancy.csv", header=T)
dredun_eff <- clean_names(dredun_eff) %>% 
  dplyr::select(-c(d, x))

dparcelas <- read.csv("C:/tesis_catie/Calderon_CATIE/data/clean/data_posicion_parcelas.csv", header = T)
dparcelas <- clean_names(dparcelas)

denvi_est <- read.csv("C:/tesis_catie/Calderon_CATIE/data/clean/data_enviroment_worldclim_clean.csv", header = T, row.names = 1)
denvi_est <- denvi_est %>%
  clean_names() %>% 
    dplyr::select(-c(crtm_90_x,crtm_90_y,forest_type, slope_per,slope_deg))

#Standarize data
denvi_est <-  scale(denvi_est,center = F, scale = T )

#scale(denvi_est,center = F, scale = T )
denvi_est <- rownames_to_column(as.data.frame(denvi_est),var= "plot") %>% 
  dplyr::select(-tempsd )
```

#Join Data sets

```{r warning=FALSE}
dfull  <- left_join(dredun_eff, dparcelas,by=c("plot") ) %>% 
  left_join(.,denvi_est, by=c("plot") )

#Ordenar columnas
dfull_est <- dfull %>% dplyr::select(plot, forest_type,longitude,latitude,crtm_90_x,crtm_90_y,n,redundancy,u , q, everything()) 
glimpse(dfull_est)
```

```{r}
#Data sets que se van a utilizar
dredundancy_eff <- dfull_est %>%
  dplyr::select(-u,-q)
  
duniqueness_eff <- dfull_est %>%
  dplyr::select(-redundancy,-q)

drao_eff <- dfull_est %>%
  dplyr::select(-u,-redundancy )
```

#Modelo lineal con componente espacial: redundancy 

```{r, fig.height=10, fig.width=10}

pca_envi <- prcomp(denvi_est[,2:17], scale. = TRUE)
pca_envi$rotation
summary(pca_envi)

ggbiplot(pca_envi, obs.scale = 3, var.scale = 3,
  groups = dfull_est$forest_type, ellipse = TRUE) +
  scale_color_discrete(name = '') +
  theme(legend.direction = 'horizontal', legend.position = 'top')+
  theme_grey()
```


##Outliers
```{r, fig.width=12, fig.height=12}

MyVar <- c("longitude", "latitude", "sand","clay","limo",
           "p_h","acidity","ca","mg","k","p","organic_matter",
           "elev","prec","precdriest","preccv","temp","tempmin")

Mydotplot(dredundancy_eff[,MyVar])

dredundancy_eff[dredundancy_eff$preccv>50,]
dredundancy_eff[dredundancy_eff$p>10,]


```


##Collinearity

```{r}
corvif(dredundancy_eff[,MyVar])
```




##Relationships
```{r, fig.width=12, fig.height=12}

MyMultipanel.ggp2(Z = dredundancy_eff, 
                  varx = MyVar, 
                  vary = "redundancy", 
                  ylab = "Response variable: Redundancia",
                              addSmoother = TRUE,
                              addRegressionLine = FALSE,
                              addHorizontalLine = FALSE)


```


```{r}
MyVar2 <- c("longitude", "latitude",
           "p_h","acidity","k","p","organic_matter"
           ,"prec","temp")
corvif(dredundancy_eff[,MyVar2])
```


##Modelo inicial 


```{r}
I1 <- inla(redundancy ~
             longitude +
             latitude +
             sand +
             limo +
             clay +
             p_h + 
             acidity + 
             ca +
             mg + 
             k +
             p + 
             organic_matter + 
             elev +
             prec +
             precdriest +
             preccv +
             tempmin +
             temp, 
          family = "gaussian",
           control.compute = list(
                               dic = TRUE,
                               waic = TRUE),
          control.predictor = list(compute = TRUE),
          data = dredundancy_eff 
          )
```


##Pearson residuals
Ver falta de hetereogenidad
```{r fig.width=12, fig.height=12 }
ExpY <- I1$summary.fitted.values[,"mean"]
E1   <- (dredundancy_eff$redundancy - ExpY) / sqrt(ExpY)

dredundancy_eff$E1 <- E1
MyMultipanel.ggp2(Z = dredundancy_eff, 
                  varx = MyVar, 
                  vary = "E1", 
                  ylab = "Pearson residuals",
                  addSmoother = TRUE,
                  addRegressionLine = FALSE,
                  addHorizontalLine = TRUE)


```



##Partial residuals
```{r fig.width=10, fig.height=12}

#obtener betas
betas <- I1$summary.fixed[,c("mean", "sd")]

#Obtener residuos
residuos   <- (dredundancy_eff$redundancy - ExpY)

betas <- (betas %>% rownames_to_column("variable") %>% 
            filter(!variable %in% "(Intercept)") %>% 
            dplyr::select(-sd))


# 1-Separar el ser de datos en una lista por variable
betas_list <- split(betas, betas$variable)

## 2-Crear una lista para almacenar 
partial_resid <- list()


##Loop
for (i in seq_along(names(betas_list))){
  
#  #Residuos de pearson + Betas = residuos parciales
  residuos_parciales <-  residuos + as.numeric(betas_list[[i]][2]) 
  
  name_var <- names(betas_list[i])
  
#  #Resultado
    data <- data.frame(residuos_parciales, name_var)
    partial_resid[[i]] <- data 

}


residuos_parciales  <-  do.call("rbind", partial_resid)


covariables <- dredundancy_eff %>% 
  dplyr::select(
    -c(plot,forest_type,crtm_90_x,crtm_90_y,n, redundancy,E1)) %>%
  gather(colnames(.),  key = "name_var", value = "valor_de_la_covariable") %>% 
  arrange(name_var)

dpart_resid <- cbind(residuos_parciales, covariables) 
dpart_resid2 <- dpart_resid[,-2]


ggplot(data = dpart_resid2) + 
  geom_point(aes(x=valor_de_la_covariable,y= residuos_parciales)) +
  facet_wrap(~name_var,scales = "free", ncol = 3) + 
  geom_smooth(data = dpart_resid2, 
              aes(x=valor_de_la_covariable,y= residuos_parciales), method = loess)
```
```{r }
I2 <- inla(redundancy ~
             longitude +
             latitude +
             sand +
             limo +
             clay +
             p_h + 
             acidity + 
             ca +
             mg + 
             k +
             p + 
             organic_matter + 
             elev +
             I(prec^2) +
             I(precdriest^2) +
             preccv +
             tempmin +
             temp, 
          family = "gaussian",
           control.compute = list(
                               dic = TRUE,
                               waic = TRUE),
          control.predictor = list(compute = TRUE),
          data = dredundancy_eff 
          )



I1$waic$waic
I2$waic$waic

```

```{r fig.width=10, fig.height=12}
#obtener betas
betas <- I2$summary.fixed[,c("mean", "sd")]

#Obtener residuos
residuos   <- (dredundancy_eff$redundancy - ExpY)

betas <- (betas %>% rownames_to_column("variable") %>% 
            filter(!variable %in% "(Intercept)") %>% 
            dplyr::select(-sd))


# 1-Separar el ser de datos en una lista por variable
betas_list <- split(betas, betas$variable)

## 2-Crear una lista para almacenar 
partial_resid <- list()


##Loop
for (i in seq_along(names(betas_list))){
  
#  #Residuos de pearson + Betas = residuos parciales
  residuos_parciales <-  residuos + as.numeric(betas_list[[i]][2]) 
  
  name_var <- names(betas_list[i])
  
#  #Resultado
    data <- data.frame(residuos_parciales, name_var)
    partial_resid[[i]] <- data 

}


residuos_parciales  <-  do.call("rbind", partial_resid)


covariables <- dredundancy_eff %>% 
  dplyr::select(
    -c(plot,forest_type,crtm_90_x,crtm_90_y,n, redundancy,E1)) %>%
  gather(colnames(.),  key = "name_var", value = "valor_de_la_covariable") %>% 
  arrange(name_var)

dpart_resid <- cbind(residuos_parciales, covariables) 
dpart_resid2 <- dpart_resid[,-2]


ggplot(data = dpart_resid2) + 
  geom_point(aes(x=valor_de_la_covariable,y= residuos_parciales)) +
  facet_wrap(~name_var,scales = "free", ncol = 3) + 
  geom_smooth(data = dpart_resid2, 
              aes(x=valor_de_la_covariable,y= residuos_parciales), method = loess)
```

```{r}
#Xkm <- dredundancy_eff$crtm_90_x / 1000
#Ykm <- dredundancy_eff$crtm_90_y / 1000
#
#
#Loc <- cbind(Xkm, Ykm)
#D <- dist(Loc)
#par(mfrow = c(1,2), mar = c(5,5,2,2), cex.lab = 1.5)
#hist(D, 
#     freq = TRUE,
#     main = "", 
#     xlab = "Distance between sites (km)",
#     ylab = "Frequency");text(2, 35000, "A", cex = 1.5)
#
#plot(x = sort(D), 
#     y = (1:length(D))/length(D), 
#     type = "l",
#     xlab = "Distance between sites (km)",
#     ylab = "Cumulative proportion")
#text(2, 1, "B", cex = 1.5)
```



```{r}
#MyData      <- data.frame(E1 = E1, 
#                          Xkm = Xkm, 
#                          Ykm = Ykm)
#
#coordinates(MyData)    <- c("Xkm", "Ykm")
#Vario <- variogram(object = E1 ~ Xkm + Ykm, 
#                    data = MyData, 
#                    cressie = TRUE, 
#                    cutoff = 2.9,
#                    width = 0.2)
#
#p <- ggplot(data = Vario, aes(x = dist, y = gamma))
#p <- p + geom_point()
#p <- p + geom_smooth(method = "gam", 
#                     formula = y ~ s(x, bs = "cs"),
#                     colour = "black") 
##p <- p + ylim(0,1)
#p <- p + theme(text = element_text(size = 15)) 
#p <- p + xlab("Distance (km)") + ylab("Sample variogram") 
#p
```

```{r}
# We need a grid on top of our sampling points
#ConvHull <- inla.nonconvex.hull(Loc)
#mesh0 <- inla.mesh.2d(boundary = ConvHull, 
#                      max.edge = c(200))
#
#mesh0$n
```

##Mesh

```{r}

#Xkm <- dredundancy_eff$crtm_90_x / 1000
#Ykm <- dredundancy_eff$crtm_90_y / 1000
#Loc <- cbind(Xkm, Ykm)
#
#ConvHull <- inla.nonconvex.hull(Loc)
#mesh1 <- inla.mesh.2d(boundary = ConvHull, 
#                      max.edge = c(1,1),
#                      cutoff = 0)
#
#mesh2 <- inla.mesh.2d(boundary = ConvHull, 
#                      max.edge = c(2,2),
#                      cutoff = 0)
#
#mesh3 <- inla.mesh.2d(boundary = ConvHull, 
#                      max.edge = c(4,4),
#                      cutoff = 0)
#
#
#mesh4 <- inla.mesh.2d(boundary = ConvHull, 
#                      max.edge = c(8,8),
#                      cutoff = 0)
#
#mesh5 <- inla.mesh.2d(boundary = ConvHull, 
#                      max.edge = c(16,16),
#                      cutoff = 0)
#
#mesh1$n
#mesh2$n
#mesh3$n
#mesh4$n
#mesh5$n
```


##Projector matrix

```{r}
#A2 <- inla.spde.make.A(mesh1,loc=Loc)
#dim(A2)
```

##SPDE

```{r}
#spde <- inla.spde2.matern(mesh1, alpha = 2)
```


##Spatial field
```{r}
#w_index <- inla.spde.make.index(
#                   name    = 'w', 
#                   n.spde  = spde$n.spde,
#                   n.group = 1,
#                   n.repl  = 1)
```

##Stack 
```{r}
#N <- nrow(dredundancy_eff)
#X <- data.frame(Intercept       = rep(1, N), 
#                p_h             = dredundancy_eff$p_h  ,   
#                acidity         = dredundancy_eff$acidity,
#                k               = dredundancy_eff$k,
#                p               = dredundancy_eff$p,
#                organic_matter  = dredundancy_eff$organic_matter, 
#                prec            = dredundancy_eff$prec,
#                temp            = dredundancy_eff$temp
#                )
```

###Tell INLA at which mesh points the covariates are sampled
```{r}
#stk2 <- inla.stack(
#             tag  = "Fit",
#             data = list(y = dredundancy_eff$redundancy),  
#	           A    = list(A2, 1),                      
#	           effects = list(                 
#	              w = w_index,           #Spatial field  
#	              X = as.data.frame(X)))  #Covariates
```


###Modelo sin componente espacial
```{r}
#f2 <- y  ~ -1 + Intercept + p_h + acidity + k + p + organic_matter + prec + temp
#I2 <- inla(f2,
#             family = "gaussian", 
#             data=inla.stack.data(stk2),
#             control.compute = list(dic = TRUE, waic = TRUE),
#             control.predictor = list(A = inla.stack.A(stk2)))
```

###Modelo con componente espacial
```{r}
#f3 <- y  ~ -1 + Intercept + p_h + acidity + k + p + organic_matter + prec + temp +f(w, model=spde)
#
#
#I3 <- inla(f3,
#             family = "gaussian", 
#             data=inla.stack.data(stk2),
#             control.compute = list(dic = TRUE, waic = TRUE),
#             control.predictor = list(A = inla.stack.A(stk2)))
```

```{r}
#f4 <- y  ~ -1 + Intercept + f(w, model=spde)
#
#I4 <- inla(f4,
#             family = "gaussian", 
#             data=inla.stack.data(stk2),
#             control.compute = list(dic = TRUE, waic = TRUE),
#             control.predictor = list(A = inla.stack.A(stk2)))
```



```{r}
#dic2  <- c(I2$dic$dic, 
#           I3$dic$dic,
#           I4$dic$dic)
#
#waic2 <- c(I2$waic$waic, 
#           I3$waic$waic,
#           I4$waic$waic)
#
#Z     <- cbind(dic2, waic2)
#rownames(Z) <- c("Gaussian GLM",  "Gaussian GLM + SPDE","Sin Covariables")
#Z

```

```{r}
#Combined <- rbind(I2$summary.fixed[, c("mean", "0.025quant", "0.975quant")],
#                  I3$summary.fixed[, c("mean", "0.025quant", "0.975quant")]
#                 )
#
#Combined$WhichModel <- rep(c("GLM", "spatial GLM"), each = 8)
#Combined$WhichVariable <- rep(rownames(I2$summary.fixed), 2)
#colnames(Combined) <- c("Mean", "Lo", "Up", "WhichModel", "WhichVariable")
#Combined
```




```{r}
# Fitted values and Pearson residuals I2
#IndexFit <- inla.stack.index(stk2, tag = "Fit")$data
#
#mu2 <- I2$summary.fitted.values[IndexFit, "mean"]
#E2 <- (dredundancy_eff$redundancy - mu2) / sqrt(mu2)
#Dispersion2 <- sum(E2^2) / (N - 8)
#Dispersion2
```


```{r}
# Fitted values and Pearson residuals I3
#mu3 <- I3$summary.fitted.values[IndexFit, "mean"]
#E3 <- (dredundancy_eff$redundancy - mu3) / sqrt(mu3)
#sum(E3^2) / (N - 8)
#Dispersion3 <- sum(E3^2) / (N - 10)
#Dispersion3
```


```{r}
# Variogram model I3
#MyData3 <- data.frame(E3 = E3, 
#                      Xkm , 
#                      Ykm )
#
#coordinates(MyData3) <- c("Xkm", "Ykm")
#
#Vario3 <- variogram(E3 ~ 1, 
#                MyData3, 
#                cressie = TRUE, 
#                cutoff = 3,
#                width = 0.2)
#
#VarioComb <- rbind(Vario, Vario3)
#
#p <- ggplot(data = Vario3, aes(x = dist, y = gamma))
#p <- p + geom_point()
#p <- p + geom_smooth(method = "gam", 
#                     formula = y ~ s(x, bs = "cs"),
#                     colour = "black") 
##p <- p + ylim(0,1)
#p <- p + theme(text = element_text(size = 15)) 
#p <- p + xlab("Distance (km)") + ylab("Sample variogram") 
##p <- p + facet_grid(~ID)
#p

```

```{r}
#w.pm <- I4$summary.random$w$mean  
#w.sd <- I4$summary.random$w$sd
#length(w.pm)
#
#wproj <- inla.mesh.projector(mesh1) 
#w.pm100_100 <- inla.mesh.project(wproj, w.pm)
#w.sd100_100 <- inla.mesh.project(wproj, w.sd)
#
#
#Grid <- expand.grid(Xkm = wproj$x, 
#                    Ykm = wproj$y)
#Grid$w.pm <- as.vector(w.pm100_100)     
#Grid$w.sd <- as.vector(w.sd100_100)               
#
#col.l <- colorRampPalette(c('red', 'green'))(50) 
#col.r <- rev(rainbow(30, alpha = 0.35))
#
#plot.wpm <- levelplot(w.pm ~ Xkm * Ykm,
#          data = Grid, 
#          aspect = "iso",
#          col.regions = col.r,
#          scales = list(draw = TRUE),
#          xlab = list("X-coordinates (km)", cex = 1.5),
#          ylab = list("Y-coordinates (km)", cex = 1.5),
#          main = list("Posterior mean spatial random field", cex = 1.5))
#plot.wpm


```


```{r}
#levelplot(w.sd ~ Xkm * Ykm,
#          col.regions = col.l,
#          data = Grid, 
#          scales = list(draw = TRUE),
#          xlab = list("X-coordinates (km)", cex = 1.5),
#          ylab = list("Y-coordinates (km)", cex = 1.5),
#          main = list("Posterior sd spatial random field", cex = 1.5))
#
```

```{r}
# Alternative code
#GridNoNA  <- na.exclude(Grid)  
#col.y <- colorRampPalette(c('red', 'yellow'))(50) 
#
#glgmap <- ggplot(GridNoNA, aes(x = Xkm, y = Ykm)) +
#    geom_raster(aes(fill = w.pm)) + 
#    scale_fill_gradientn(colours = col.y) +
#    coord_fixed()
#glgmap
#
#  
#u.proj <- inla.mesh.projector(mesh = mesh1, loc = Loc)
#u.mean <- inla.mesh.project(u.proj, I3$summary.random$w$mean)
#dredundancy_eff$u.mean <- u.mean
#dredundancy_eff$Col    <- abs(u.mean)  #c(0,1)[as.numeric(u.mean > 0) + 1]
#
#glgmap +
#  geom_point(data = dredundancy_eff, 
#             aes(Xkm, Ykm, 
#               colour = Col
#                ),
#             size = 2.5,
#             show.legend = FALSE) +
#             scale_shape_manual(values=c(16, 1)) +
#             #scale_color_gradient(low="black", high="green") +
#xlab("X-coordinates (km)") + ylab("Y-coordinates (km)")+
#theme(text = element_text(size=15))#, legend.position="none") 

```

